---
title: "Нужны ли алгоритмы джуну? Разбираемся с основами"
tags: ["Алгоритмы"]
date: "2021-03-02"
active: "true"
ready: "true"
---

## О чем поговорим?

- Нужно ли знать алгоритмы джуну?
- Что такое алгоритмы?
- Что такое "О-большое"?
- Решаем простую задачу и определяем ее сложность
- Применение алгоритмов в различных сферах
- Полезные ресурсы и книги для изучения алгоритмов

## Нужно ли знать алгоритмы джуну?

Для того, чтобы пройти собес на джуна, знание алгоритмов не потребуется.
Я бы сказал, что на данном этапе это вне вашей компетенции.

Конечно, будет большим плюсом, если вы уже имеете некоторое представление
в этой области. Это поможет вам осознанно писать более качественный код. Но на собеседовании
вас вряд ли попросят оценить сложность решения с точки зрения алгоритмов.

Но если вы знакомы с базовой алгеброй и сможете решить подобное уравнение:

```javascript
f(x) = x * 5
f(5) = 25
``` 

то для вас не составит труда освоить алгоритмы.
Также обязательным правилом является знание на базовом уровне хотя бы одного из языков программирования.

## Что такое алгоритмы?

Когда мы совершаем какие-либо действия в повседневной жизни,
мы делаем набор инструкций. Это называется алгоритм.

В целом любой кусок кода, это набор инструкций, а значит тоже алгоритм.

```javascript
// Это тоже алгоритм
console.log(1);
console.log(2);
console.log(3);
```

Но когда мы говорим об алгоритмах в программировании, мы имеем в виду
что-то более сложное. Это некоторые правила, которые помогают нам оптимизировать
наши решения и писать более быстрый и производительный код.

## Что такое "О-большое"

Для того, чтобы знать о том, насколько производителен наш код,
нам необходимо иметь какую-то единицу измерения скорости нашего алгоритма.

> Нотация "О-большое" - описывает скорость работы алгоритма

Это первое, о чем вас спросят на собеседовании, если решат затронуть тему алгоритмов.

### Таблица сложностей отсортированная по времени

| Сложность        | Расшифровка           | Описание  |
| ------------- |:-------------:| -----:|
| O(1)      | Константное время | Не зависит от входных параметров. Время выполнения может быть как 1 секунду так и миллиард, но зависит оно от каких-то внешних факторов, например количества ресурсов на сервере, объем оперативной памяти и тд. |
| O(n)      | Линейное      |   Количество операций растет пропорционально количеству входных параметров. Например, если поиск в массиве из 100 элементов занимает 100 операций, то поиск в 10000 будет занимать 10000 операций |
| O(n*log(n)) | Линеарифмический      | Быстрая сортировка сравнением |
| O(log(n)) | Логарифмическое. логарифм по снованию 2      |  Скорость выполнения тоже зависит от количества входных параметров, но растет медленнее. Например поиск в 100 элементах займет примерно 7 операций, а в 10000 примерно 13 операций |
| O(O(n^2)) | Квадратичный. Очень долго. (Сортировка пузырьком)      |  Количество операций будет равно количеству входных параметров возведенное в квадрат |

Это еще не все. Но самые распространенные. <a href="https://ru.wikipedia.org/wiki/Временная_сложность_алгоритма#Константное_время" target="_blank">Тут можно ознакомится с остальными.</a>

Все эти формулы сложности алгоритма за исключением О(1), зависят от количества входных параметров, который выражается в виде переменной n.

Важно запомнить, что все эти сложности отличаются друг от друга тем, что время выполнения у них растет с разной скоростью.

### Что значит время выполнения растет с разной скоростью?

Например у нас стоит выбор между алгоритмом O(n) и O(log(n)).

Вы полагаем, что алгоритм со сложностью O(n) и с количеством входных параметров равным 100 выполнится за 100 операций.
Так как скорость линейная, это значит, что количество операций растет пропорционально количеству входных параметров.

При этом время выполнения алгоритма со сложностью O(log(n)) и с таким же количеством операций будет равно примерно 7 операций.
Так как логарифм числа по основанию 2 это степень, в которую нужно возвести 2, чтобы получить наше число.

**Значит ли это, что второй алгоритм в 15 раз быстрее первого, так как 100 / 7 будет равно примерно 15.**

Нет! Так как с увеличением количества входных параметров, время выполнения алгоритмов будет расти с разной скоростью.

```javascript
O(1000000) = 1000000
O(log(1000000)) = 19
```

В данном случае второй алгоритм быстрее первого примерно в 52000 раз.

**Важно запомнить, что O большое, не говорит нам о том, за какое время алгоритм закончит свою работу. Он лишь сообщает о количестве операций. Но это могут быть как секунды, так и минуты и даже часы.**

### Решаем простую задачу и оптимизируем ее

Часто говорят, что в сфере фронтенд не нужны алгоритмы. Но на самом деле это не так.
Алгоритмы могут пригодиться, где вы часто выполняете операции связанные с обходом массива.

Например одна из таких задач:

**На вход мы получаем две строки. Нам необходимо определить, являются ли эти строки анаграммами по отношению друг к другу**

В результате наш метод должен возвращать следующее

```javascript
  it("Test 1", () => {
    expect(isAnagram("restful", "fluster")).toBe(true);
  });
  it("Test 2", () => {
    expect(isAnagram("qqwwe", "qwwee")).toBe(false);
  });
```

Что первое приходит в голову?

Например, отсортировать две строки. Это нам даст возможность пробегаться по одной строке как по массиву
и сравнивать символы с другой строкой. Если мы встречаем не совпадающий символ, то строки не являются анаграммами.

```javascript
function isAnagram(str1, str2) {
  const strArr = str1.toLowerCase().replace(/ /g, "").split("").sort();
  const str2Arr = str2.toLowerCase().replace(/ /g, "").split("").sort();

  const strArrSize = strArr.length;

  if (strArrSize !== str2Arr.length) return false;

  for (let i = 0; i < strArrSize - 1; i++) {
    if (strArr[i] !== str2Arr[i]) {
      return false;
    }
  }

  return true;
}
```

С какой сложностью выполнится данный алгоритм?

Внутри функции мы итерируемся по массиву элементов. А значит, можно предположить, что сложность нашего алгоритма будет O(n).

**Но это не так!** Мы также выполняем сортировку наших массивов. Метод sort в javascript выполняется за O(n*log(n)) операций.

Это значит дольше, чем O(n), а значит, что весь алгоритм выполнится за O(n*log(n)) операций. Так как мы всегда берем за основу самую сложную операцию.


### Как можно улучшить наше решение?

Попробуем переписать его так, чтобы он выполнялся за O(n) операций.

```javascript
function isAnagram(str1, str2) {
  const strArr = str1.toLowerCase().replace(/ /g, "").split("");
  const str2Arr = str2.toLowerCase().replace(/ /g, "").split("");

  const strArrSize = strArr.length;
  const str2ArrSize = str2Arr.length;

  const result = {};

  if (strArrSize !== str2Arr.length) return false;
  for (let i = strArrSize - 1; i >= 0; i--) {
    if (strArr[i] in result) {
      result[strArr[i]] += 1;
    } else {
      result[strArr[i]] = 1;
    }
  }
  console.log(result);
  for (let i = str2ArrSize - 1; i >= 0; i--) {
    if (str2Arr[i] in result) {
      result[str2Arr[i]] -= 1;
    } else {
      return false;
    }
  }
  return !Object.values(result).find((value) => value !== 0);
}
```

Наше решение стало более громоздким, но зато более оптимизированным. Мы избавились от метода sort, и нашли более оптимальный способ.

## Применение алгоритмов в различных сферах

Не стоит пренебрегать алгоритмами. И если вы уже достаточно уверенный джун, нашли свою первую работу, то я рекомендую
как можно раньше взяться за изучение алгоритмов.

Это пригодится вам абсолютно в любом направлении в программировании, даже во фронтенде.
Это будет напрямую влиять на конечную скорость работы вашего приложения. Особенно это будет заметно в больших проектах.

## Полезные ресурсы и книги для изучения алгоритмов

- <a href="https://github.com/trekhleb/javascript-algorithms" target="_blank">Задачи на алгоритмы Javascript</a>
- <a href="http://aliev.me/runestone/" target="_blank">Перевод крутой книги про алгоритмы</a>
- <a href="https://www.ozon.ru/context/detail/id/139296295/" target="_blank">Книга грокаем алгоритмы</a>. Ее можно найти бесплатно, но я этого не говорил.
- <a href="https://github.com/TheAlgorithms/Java" target="_blank">Задачи на алгоритмы Java</a>
- <a href="https://stepik.org/course/1547/promo" target="_blank">Бесплатный курс по алгоритмам и структурам данных</a>
- <a href="https://www.hackerrank.com/dashboard" target="_blank">Тут можно порешать задачки</a>
